/// <reference types="virtual-dom" />
/** @module Core */ /** */
import { VNode } from 'virtual-dom';
import { Moment } from 'moment';
import i18next from 'i18next';
declare type PersistentProperties = 'Type' | 'Name';
declare type PartialTyped<T> = T extends object ? {
    [K in Extract<keyof T, PersistentProperties>]: T[K];
} & {
    [K in Exclude<keyof T, PersistentProperties>]?: T[K] extends (infer T2)[] ? PartialTyped<T2>[] : PartialTyped<T[K]>;
} : T;
declare type RDLExpr<TR> = string | TR;
declare type WithStringExpr<T> = T extends Expr<infer U> ? RDLExpr<U> : (T extends object ? {
    [K in keyof T]: WithStringExpr<T[K]>;
} : T);
declare type Variant = (number | string) | null;
declare type Color = string;
declare type Expr<T> = () => T;
declare type Length = string;
declare type ItemType<T extends string> = {
    Type: T;
};
declare type BreakLocation = 'Start' | 'End' | 'StartAndEnd' | 'Between' | 'None';
declare type DataElementOutput = 'Auto' | 'Output' | 'NoOutput' | 'ContentsOnly';
declare type DataElementStyle = 'Auto' | 'Attribute' | 'Element';
declare type Visibility = {
    Hidden: Expr<boolean>;
    ToggleItem: string;
};
declare type BorderStyle = 'Default' | 'None' | 'Dotted' | 'Dashed' | 'Solid' | 'Double';
declare type BorderSideStyle = {
    Color: Expr<Color>;
    Style: Expr<BorderStyle>;
    Width: Expr<Length>;
};
declare type RoundingRadius = {
    Default: Expr<Length>;
    TopLeft: Expr<Length>;
    TopRight: Expr<Length>;
    BottomLeft: Expr<Length>;
    BottomRight: Expr<Length>;
};
declare type FontStyle = 'Default' | 'Normal' | 'Italic';
declare type FontWeight = 'Default' | 'Thin' | 'ExtraLight' | 'Light' | 'Normal' | 'Medium' | 'SemiBold' | 'Bold' | 'ExtraBold' | 'Heavy';
declare type TextDecoration = 'Default' | 'None' | 'Underline' | 'Overline' | 'LineThrough';
declare type TextAlign = 'Default' | 'General' | 'Left' | 'Center' | 'Right';
declare type VerticalAlign = 'Default' | 'Top' | 'Middle' | 'Bottom';
declare type Direction = 'Default' | 'LTR' | 'RTL';
declare type WritingMode = 'Default' | 'Horizontal' | 'Vertical';
declare type Calendar = 'Default' | 'Gregorian' | 'GregorianArabic' | 'GregorianMiddleEastFrench' | 'GregorianTransliteratedEnglish' | 'GregorianTransliteratedFrench' | 'GregorianUSEnglish' | 'Hebrew' | 'Hijri' | 'Japanese' | 'Korean' | 'Taiwan' | 'ThaiBuddhist';
declare type WrapMode = 'NoWrap' | 'CharWrap' | 'WordWrap';
declare type BackgroundGradientType = 'None' | 'LeftRight' | 'TopBottom' | 'Center' | 'DiagonalLeft' | 'DiagonalRight' | 'HorizontalCenter' | 'VerticalCenter';
declare type TextJustify = 'Auto' | 'Inter-Word' | 'Inter-Ideograph' | 'Inter-Cluster' | 'Distribute' | 'Kashida' | 'Trim' | 'Initial' | 'Inherit';
declare type UnicodeBiDi = 'Normal' | 'Embed' | 'BidiOverride';
declare type ImageSource = 'External' | 'Embedded' | 'Database';
declare type ShapeStyle = 'Rectangle' | 'RoundRect' | 'Ellipse';
declare type BackgroundImage = {
    Source: ImageSource;
    Value: any;
    MIMEType: string;
    BackgroundRepeat: string;
};
declare type CommonStyle = {
    Border: BorderSideStyle;
    TopBorder: BorderSideStyle;
    RightBorder: BorderSideStyle;
    BottomBorder: BorderSideStyle;
    LeftBorder: BorderSideStyle;
    BackgroundColor: Expr<Color>;
    BackgroundGradientEndColor: Expr<Color>;
    BackgroundGradientType: Expr<BackgroundGradientType>;
    BackgroundImage: BackgroundImage;
    FontStyle: Expr<FontStyle>;
    FontFamily: Expr<string>;
    FontSize: Expr<Length>;
    FontWeight: Expr<FontWeight>;
    LineHeight: Expr<Length>;
    LineSpacing: Expr<Length>;
    CharacterSpacing: Expr<Length>;
    Format: Expr<string>;
    TextDecoration: Expr<TextDecoration>;
    TextAlign: Expr<TextAlign>;
    VerticalAlign: Expr<VerticalAlign>;
    WrapMode: Expr<WrapMode>;
    Color: Expr<Color>;
    PaddingLeft: Expr<Length>;
    PaddingRight: Expr<Length>;
    PaddingTop: Expr<Length>;
    PaddingBottom: Expr<Length>;
    Direction: Expr<Direction>;
    WritingMode: Expr<WritingMode>;
    Language: Expr<string>;
    Calendar: Expr<Calendar>;
    NumeralLanguage: Expr<string>;
    NumeralVariant: Expr<number>;
    UnicodeBiDi: Expr<UnicodeBiDi>;
    TextIndent: Length;
    LeadingChar: string;
    MaxLevel: Expr<number>;
    HeadingLevel: Expr<number>;
    ShrinkToFit: Expr<boolean>;
    TextJustify: TextJustify;
    Angle: string;
    MinCondenseRate: Expr<number>;
};
declare type Style<A extends keyof CommonStyle> = Pick<CommonStyle, A>;
declare type BorderPropNames = 'Border' | 'TopBorder' | 'BottomBorder' | 'RightBorder' | 'LeftBorder';
declare type PaddingPropNames = 'PaddingLeft' | 'PaddingRight' | 'PaddingTop' | 'PaddingBottom';
declare type FontPropNames = 'FontFamily' | 'FontSize' | 'FontStyle' | 'FontWeight';
declare type TextPropNames = FontPropNames | PaddingPropNames | 'Color' | 'Format' | 'LineHeight' | 'TextAlign' | 'TextDecoration' | 'VerticalAlign' | 'Calendar' | 'Direction' | 'Language' | 'NumeralLanguage' | 'NumeralVariant' | 'UnicodeBiDi' | 'WritingMode';
declare type RichTextPropNames = FontPropNames | PaddingPropNames | 'Color' | 'LineHeight';
declare type ReportStyleReportItem = {
    ReportStyle: {
        StyleId: string;
        StyleName: string;
    };
};
declare type Section = ItemType<'section'> & {
    Name: string;
    Height: Length;
    ReportItems: Array<ReportItem>;
    Style: Style<BorderPropNames | 'BackgroundColor' | 'BackgroundImage'>;
};
declare type PageSection = ItemType<'pagesection'> & {
    PrintOnFirstPage: boolean;
    PrintOnLastPage: boolean;
    Name: string;
    Height: Length;
    ReportItems: Array<ReportItem>;
    Style: Style<BorderPropNames | 'BackgroundColor' | 'BackgroundImage'>;
};
declare type Page = {
    BottomMargin: Length;
    Columns: number;
    ColumnSpacing: Length;
    LeftMargin: Length;
    PageHeight: Length;
    PageWidth: Length;
    RightMargin: Length;
    TopMargin: Length;
};
declare type DocumentMap = {
    Source: 'None' | 'Labels' | 'Headings' | 'All';
    NumberingStyle: string;
    Levels: Array<string>;
};
declare type CustomProperty = {
    Name: Expr<string>;
    Value: Expr<Variant>;
};
declare type FixedPageItem = ItemType<'fixedpagesection'> & {
    ReportItems: Array<ReportItem>;
    Style: Style<BorderPropNames | 'BackgroundColor' | 'BackgroundImage'>;
    ThrowIfPlaceHoldersEmpty: boolean;
};
declare type FixedPage = ItemType<'fixedpage'> & {
    Name: string;
    Pages: Array<FixedPageItem>;
    Group: Group | null;
    DataSetName: string;
    Filters: Array<Filter>;
    SortExpressions: Array<SortExpression>;
    DataElementName: string;
    DataElementOutput: DataElementOutput;
};
declare type EmbeddedImage = {
    Name: string;
    ImageData: string;
    MIMEType: string;
};
declare type Report = ItemType<'report'> & {
    Name: string;
    Description: string;
    Author: string;
    FixedPage: FixedPage | null;
    PageHeader: PageSection | null;
    Body: Section | null;
    PageFooter: PageSection | null;
    Page: Page;
    Width: Length;
    Language: Expr<string>;
    ConsumeContainerWhitespace: boolean;
    CustomProperties: Array<CustomProperty>;
    DataElementName: string;
    DataElementStyle: 'Attribute' | 'Element';
    DocumentMap: DocumentMap;
    ReportParameters: Array<ReportParameter>;
    DataSources: Array<DataSource>;
    DataSets: Array<DataSet>;
    EmbeddedImages: Array<EmbeddedImage>;
    ThemeUri: string;
    StartPageNumber: number;
    LocalizationResources: Array<LocalizationResource>;
    Layers: Array<Layer>;
};
declare type Layer = ItemType<'layer'> & {
    Name: string;
    DesignerLock: boolean;
    DesignerTransparency: number;
    DesignerVisible: boolean;
    TargetDevice: string;
};
declare type ReportParameterType = 'Boolean' | 'Date' | 'DateTime' | 'Integer' | 'Float' | 'String';
declare type ReportParameter = {
    AllowBlank: boolean;
    DataType: ReportParameterType;
    DateOnly: boolean;
    DefaultValue: ReportParameterDefaultValue;
    Hidden: boolean;
    Multiline: boolean;
    MultiValue: boolean;
    Name: string;
    Nullable: boolean;
    Prompt: string;
    SelectAllValue: Expr<Variant> | undefined;
    UsedInQuery: ThreeStateBool;
    ValidValues: ReportParameterValidValue;
};
declare type DataSetReference = {
    DataSetName: string;
    ValueField: string;
    LabelField: string;
};
declare type ReportParameterDefaultValue = {
    Values: Expr<Variant>[];
} | {
    DataSetReference: DataSetReference;
};
declare type ReportParameterValidValue = {
    ParameterValues: {
        Value: Expr<Variant>;
        Label: Expr<Variant>;
    }[];
} | {
    DataSetReference: DataSetReference;
};
declare type FilterOperator = 'Equal' | 'Like' | 'NotEqual' | 'GreaterThan' | 'GreaterThanOrEqual' | 'LessThan' | 'LessThanOrEqual' | 'TopN' | 'BottomN' | 'TopPercent' | 'BottomPercent' | 'In' | 'Between';
declare type Filter = {
    FilterExpression: Expr<Variant>;
    Operator: FilterOperator;
    FilterValues: Array<Expr<Variant>>;
};
declare type SortDirection = 'Ascending' | 'Descending';
declare type SortExpression = {
    Value: Expr<Variant>;
    Direction: SortDirection;
};
declare type Group = {
    Name: string;
    DocumentMapLabel: Expr<string>;
    GroupExpressions: Array<Expr<Variant>>;
    PageBreak: BreakLocation;
    PageBreakDisabled: Expr<boolean>;
    Filters: Array<Filter>;
    ParentGroup: Expr<Variant>;
    DataElementName: string;
    DataElementOutput: DataElementOutput;
    NewSection: boolean;
};
declare type DynamicGrouping = {
    Grouping: Group;
    Sorting: Array<SortExpression>;
    Label: Expr<string>;
};
declare type StaticGrouping = {
    StaticMembers: Array<Expr<Variant>>;
};
declare type UserSort = {
    SortExpression: Expr<string>;
    SortExpressionScope: string;
    SortTarget: string;
};
declare type ReportItemProps = {
    Top: Length;
    Left: Length;
    Width: Length;
    Height: Length;
    ZIndex: number;
    Visibility: Visibility;
    ToolTip: Expr<string>;
    Bookmark: Expr<string>;
    DataElementName: string;
    DataElementOutput: DataElementOutput;
    Label: Expr<string>;
    LayerName: string;
    Name: string;
    Action: Action;
    Style: Style<never>;
};
declare type ReportItem = TextBox | CheckBox | Rectangle | Tablix | Table | OverflowPlaceHolder | List | BandedList | Line | TableOfContents | Sparkline | Subreport | Image | Chart | Shape | Bullet | DVChart | Barcode | InputField | FormattedText | RichText;
declare type OverflowPlaceHolder = ItemType<'overflowplaceholder'> & ReportItemProps & {
    OverflowName: string | null;
};
declare type LinePoint = {
    X: Length;
    Y: Length;
};
declare type LineItemProps = {
    StartPoint: LinePoint;
    EndPoint: LinePoint;
    LineWidth: Expr<Length>;
    LineStyle: Expr<BorderStyle>;
    LineColor: Expr<Color>;
};
declare type Line = ItemType<'line'> & ReportItemProps & LineItemProps;
declare type ToggleImage = {
    InitialState: Expr<boolean>;
};
declare type TextBoxItemStyle = Style<BorderPropNames | TextPropNames | 'BackgroundColor' | 'BackgroundImage' | 'TextJustify' | 'WrapMode' | 'ShrinkToFit' | 'LineHeight' | 'LineSpacing' | 'CharacterSpacing' | 'Angle' | 'HeadingLevel' | 'MinCondenseRate'>;
declare type TextBoxProps = {
    CanGrow: boolean;
    CanShrink: boolean;
    DataElementStyle: DataElementStyle;
    KeepTogether: boolean;
    ToggleImage: ToggleImage;
    UserSort: UserSort;
    Value: Expr<Variant>;
    Style: TextBoxItemStyle;
};
declare type TextBox = ItemType<'textbox'> & ReportItemProps & TextBoxProps;
declare type TextItemStyle = Style<FontPropNames | 'Color' | 'LineSpacing' | 'BackgroundColor' | 'TextDecoration'> & {
    TextAlign?: Expr<'Left' | 'Center' | 'Right'>;
};
declare type TextRun = {
    Action: Action;
    Label: string;
    Value: Expr<string>;
    StyleName: string;
    Style: Partial<TextItemStyle> & {
        Subscript?: Expr<boolean>;
        Superscript?: Expr<boolean>;
    };
    ToolTip: Expr<string>;
};
declare type Paragraph = {
    TextRuns: TextRun[];
    LeftIndent?: Expr<Length>;
    RightIndent?: Expr<Length>;
    HangingIndent?: Expr<Length>;
    StyleName: string;
    Style: Partial<TextItemStyle>;
    ListStyle: 'None' | 'Numbered' | 'Bullet';
    ListStyleType?: 'None' | 'Disc' | 'Circle' | 'Square' | 'Decimal' | 'DecimalLeadingZero' | 'CircledNumber' | 'LowerRoman' | 'UpperRoman' | 'LowerLatin' | 'UpperLatin' | 'LowerGreek' | 'UpperGreek' | 'Katakana' | 'KatakanaBrackets' | 'KatakanaIrohaBrackets' | 'KatakanaIroha' | 'KatakanaLower' | 'KatakanaIrohaLower';
    ListLevel: number;
    ListItemIndex: number;
    SpaceBefore?: Expr<Length>;
    SpaceAfter?: Expr<Length>;
};
declare type RichTextItemStyle = Style<BorderPropNames | RichTextPropNames | 'BackgroundColor' | 'BackgroundImage'>;
declare type RichTextValue = {
    MarkupType: 'HTML';
    Value: Expr<Variant>;
} | {
    MarkupType: 'None';
    Paragraphs: Paragraph[];
};
declare type RichTextProps = RichTextValue & {
    CanGrow: boolean;
    DataElementStyle: DataElementStyle;
    KeepTogether: boolean;
    Style: RichTextItemStyle;
};
declare type RichText = ItemType<'richtext'> & ReportItemProps & RichTextProps;
declare type Shape = ItemType<'shape'> & ReportItemProps & {
    RoundingRadius: RoundingRadius;
    ShapeStyle: Expr<ShapeStyle>;
    Style: Style<BorderPropNames | 'BackgroundColor' | 'BackgroundImage'>;
};
declare type CheckBoxProps = {
    CheckAlignment: 'TopLeft' | 'TopCenter' | 'TopRight' | 'MiddleLeft' | 'MiddleCenter' | 'MiddleRight' | 'BottomLeft' | 'BottomCenter' | 'BottomRight';
    Text: Expr<Variant>;
    Checked: Expr<boolean>;
    Style: Style<BorderPropNames | PaddingPropNames | FontPropNames | 'BackgroundColor' | 'BackgroundImage' | 'Color' | 'WrapMode' | 'TextDecoration'>;
    DataElementStyle: DataElementStyle;
};
declare type CheckBox = ItemType<'checkbox'> & ReportItemProps & CheckBoxProps;
declare type InputFieldItemStyle = Style<BorderPropNames | 'BackgroundColor' | 'Color' | 'TextAlign' | FontPropNames | 'Format' | PaddingPropNames>;
declare type InputField = ItemType<'inputfield'> & ReportItemProps & {
    InputType: 'Text' | 'CheckBox';
    Value: Expr<Variant>;
    Style: InputFieldItemStyle;
    FieldName: string;
    Readonly: boolean;
    Required: boolean;
    Password: boolean;
    Multiline: boolean;
    SpellCheck: boolean;
    MaxLength: number | null;
    Checked: Expr<boolean>;
    CheckStyle: 'Check' | 'Circle' | 'Cross' | 'Diamond' | 'Square' | 'Star';
    CheckSize: Expr<Length>;
};
declare type RectangleProps = {
    PageBreak: BreakLocation;
    KeepTogether: boolean;
    RoundingRadius: RoundingRadius;
    ConsumeWhiteSpace: boolean;
    Style: Style<BorderPropNames | 'BackgroundColor' | 'BackgroundImage'>;
};
declare type Rectangle = ItemType<'rectangle'> & ReportItemProps & RectangleProps & {
    ReportItems: ReportItem[];
};
declare type ImageHorizontalAlignment = 'Left' | 'Center' | 'Right';
declare type ImageVerticalAlignment = 'Top' | 'Middle' | 'Bottom';
declare type ImageProps = {
    Source: ImageSource;
    Value: Expr<string>;
    MIMEType: Expr<string>;
    Sizing: 'AutoSize' | 'Fit' | 'FitProportional' | 'Clip';
    HorizontalAlignment: Expr<ImageHorizontalAlignment>;
    VerticalAlignment: Expr<ImageVerticalAlignment>;
    Style: Style<BorderPropNames | PaddingPropNames>;
};
declare type Image = ItemType<'image'> & ReportItemProps & ImageProps;
declare type FixedSizeReportItem = ReportItemProps & {
    FixedWidth: Length | null;
    FixedHeight: Length | null;
    OverflowName: string | null;
};
declare type DataRegionProps = {
    NoRowsMessage: Expr<string>;
    DataSetName: string;
    DataSetParameters: QueryParameter[];
    PageBreak: BreakLocation;
    Filters: Filter[];
    NewSection: boolean;
};
declare type ListProps = {
    SortExpressions: Array<SortExpression>;
    KeepTogether: boolean;
    ConsumeWhiteSpace: boolean;
    DataInstanceName: string;
    DataInstanceElementOutput: 'Output' | 'NoOutput';
    Group: Group;
    Style: Style<BorderPropNames | 'BackgroundColor' | 'BackgroundImage' | TextPropNames>;
};
declare type List = ItemType<'list'> & FixedSizeReportItem & DataRegionProps & ListProps & {
    ReportItems: ReportItem[];
};
declare type BandedListBandProps = {
    Name: string;
    CanShrink: boolean;
    CanGrow: boolean;
    KeepTogether: boolean;
    Height: Length;
    Visibility: Visibility;
    PageBreak: BreakLocation;
};
declare type BandedListGroupProps = {
    Group: Group;
    SortExpressions: SortExpression[];
    Visibility: Visibility;
    KeepTogether: boolean;
    PreventOrphanedHeader: boolean;
    PreventOrphanedFooter: boolean;
};
declare type BandedListHeader = ItemType<'bandedlistheader'> & BandedListBandProps & {
    RepeatOnNewPage: boolean;
    ReportItems: ReportItem[];
};
declare type BandedListDetails = ItemType<'bandedlistdetails'> & BandedListBandProps & {
    ReportItems: ReportItem[];
};
declare type BandedListFooter = ItemType<'bandedlistfooter'> & BandedListBandProps & {
    RepeatOnNewPage: boolean;
    PrintAtBottom: boolean;
    ReportItems: ReportItem[];
};
declare type BandedListGroup = ItemType<'bandedlistgroup'> & BandedListGroupProps & {
    Header: BandedListHeader | null;
    Footer: BandedListFooter | null;
};
interface BandedListProps {
    readonly KeepTogether: boolean;
    readonly ConsumeWhiteSpace: boolean;
    readonly PreventOrphanedHeader: boolean;
    readonly PreventOrphanedFooter: boolean;
    readonly Header: BandedListHeader | null;
    readonly Details: BandedListDetails | null;
    readonly Footer: BandedListFooter | null;
    readonly Groups: BandedListGroup[];
}
declare type BandedList = ItemType<'bandedlist'> & FixedSizeReportItem & Pick<DataRegionProps, Exclude<keyof DataRegionProps, 'NoRowsMessage'>> & BandedListProps;
declare type AutoMergeMode = 'Never' | 'Always' | 'Restricted';
declare type Tablix = ItemType<'tablix'> & FixedSizeReportItem & DataRegionProps & ReportStyleReportItem & TablixProps;
declare type TablixProps = {
    readonly SortExpressions: SortExpression[];
    readonly KeepTogether: boolean;
    readonly CustomProperties: CustomProperty[];
    readonly RepeatColumnHeaders: boolean;
    readonly RepeatRowHeaders: boolean;
    readonly GroupsBeforeRowHeaders: number;
    readonly LayoutDirection: Direction;
    readonly RowHierarchy: TablixHierarchy;
    readonly ColumnHierarchy: TablixHierarchy;
    readonly Corner: TablixCornerRow[];
    readonly Body: TablixBody;
    readonly Style: Style<BorderPropNames | TextPropNames | 'BackgroundColor' | 'BackgroundImage'>;
};
declare type TablixHeader = {
    Item: ReportItem;
    LevelCount: number;
};
declare type TablixBody = TablixBodyA<ReportItem>;
declare type TablixCornerRow = TablixCornerRowA<ReportItem>;
interface TablixMember {
    readonly Type: 'tablixmember';
    readonly Group: Group | null;
    readonly SortExpressions: Array<SortExpression>;
    readonly Header: TablixHeader | null;
    readonly BodyIndex: number;
    readonly BodyCount: number;
    readonly Children: Array<TablixMember>;
    readonly Visibility: Visibility;
    readonly KeepWithGroup: 'None' | 'Before' | 'After';
    readonly DataElementName: string;
    readonly DataElementOutput: DataElementOutput;
    readonly RepeatOnNewPage: boolean;
    readonly KeepTogether: boolean;
}
declare type TablixCellA<TReportItem extends object> = {
    RowSpan: number;
    ColSpan: number;
    AutoMergeMode: AutoMergeMode;
    Item: TReportItem;
};
declare type TablixRowA<TReportItem extends object> = {
    Height: Length;
    Cells: Array<TablixCellA<TReportItem> | null>;
};
declare type TablixBodyA<TReportItem extends object> = {
    Columns: Length[];
    Rows: TablixRowA<TReportItem>[];
};
declare type TablixCornerCellA<TReportItem extends object> = Pick<TablixCellA<TReportItem>, Exclude<keyof TablixCellA<TReportItem>, 'AutoMergeMode'>>;
declare type TablixCornerRowA<TReportItem extends object> = Array<TablixCornerCellA<TReportItem> | null>;
declare type TablixHierarchy = {
    LevelSizes: Array<Length>;
    Members: TablixMember[];
};
declare type TableColumn = ItemType<'tablecolumn'> & {
    Width: Length;
    FixedHeader: boolean;
    Visibility: Visibility;
};
declare type TableHeaderA<TReportItem extends object> = ItemType<'tableheader'> & {
    FixedHeader: boolean;
    TableRows: TableRowA<TReportItem>[];
    RepeatOnNewPage: boolean;
};
declare type TableFooterA<TReportItem extends object> = ItemType<'tablefooter'> & {
    PrintAtBottom: boolean;
    TableRows: TableRowA<TReportItem>[];
    RepeatOnNewPage: boolean;
};
declare type TableDetailsA<TReportItem extends object> = ItemType<'tabledetails'> & {
    TableRows: TableRowA<TReportItem>[];
    Group: Group;
    SortExpressions: SortExpression[];
    Visibility: Visibility;
};
declare type TableRowA<TReportItem extends object> = ItemType<'tablerow'> & {
    Height: Length;
    Visibility: Visibility;
    TableCells: (TableCellA<TReportItem> | null)[];
};
declare type TableCellA<TReportItem extends object> = {
    Item: TReportItem;
    ColSpan: number;
    RowSpan: number;
    AutoMergeMode: AutoMergeMode;
};
declare type TableGroupA<TReportItem extends object> = ItemType<'tablegroup'> & {
    Group: Group;
    SortExpressions: SortExpression[];
    Header: TableHeaderA<TReportItem> | null;
    Footer: TableFooterA<TReportItem> | null;
    Visibility: Visibility;
    KeepTogether: boolean;
    PreventOrphanedFooter: boolean;
};
declare type TableGroup = TableGroupA<ReportItem>;
declare type TableHeader = TableHeaderA<ReportItem>;
declare type TableFooter = TableFooterA<ReportItem>;
declare type TableDetails = TableDetailsA<ReportItem>;
interface TableStruct {
    readonly TableColumns: TableColumn[];
    readonly Header: TableHeader | null;
    readonly TableGroups: TableGroup[];
    readonly Details: TableDetails | null;
    readonly Footer: TableFooter | null;
}
declare type TableProps = {
    KeepTogether: boolean;
    FillPage: boolean;
    DetailDataElementName: string;
    DetailDataCollectionName: string;
    DetailDataElementOutput: DataElementOutput;
    FrozenRows: number;
    FrozenColumns: number;
    RepeatToFill: boolean;
    PreventOrphanedFooter: boolean;
    SortExpressions: SortExpression[];
    Style: Style<BorderPropNames | 'BackgroundColor' | 'BackgroundImage' | TextPropNames>;
};
declare type Table = ItemType<'table'> & FixedSizeReportItem & DataRegionProps & TableProps & TableStruct;
declare type TableOfContentsProps = {
    Levels: TableOfContentsLevel[];
    PageBreak: BreakLocation;
    Style: Style<BorderPropNames | 'BackgroundColor' | 'MaxLevel'>;
    FixedWidth: null;
};
declare type TableOfContents = ItemType<'tableofcontents'> & ReportItemProps & FixedSizeReportItem & TableOfContentsProps;
declare type TableOfContentsLevel = {
    LevelName: string;
    DataElementName: string;
    DisplayFillCharacters: boolean;
    DisplayPageNumber: boolean;
    Style: Style<FontPropNames | PaddingPropNames | 'BackgroundColor' | 'Color' | 'TextDecoration' | 'TextAlign' | 'LeadingChar' | 'TextIndent'>;
};
declare type GradientType = 'None' | 'LeftRight' | 'TopBottom' | 'Center' | 'DiagonalLeft' | 'DiagonalRight' | 'HorizontalCenter' | 'VerticalCenter';
declare type SparklineType = 'Line' | 'Columns' | 'Whiskers' | 'Area' | 'StackedBar';
declare type SparklineProps = {
    DataSetName: string;
    DataSetParameters: QueryParameter[];
    Filters: Filter[];
    FillColor: Expr<Color>;
    GradientStyle: GradientType;
    GradientEndColor: Expr<Color>;
    LineColor: Expr<Color>;
    LineWidth: Length;
    MarkerColor: Expr<Color>;
    MarkerVisibility: boolean;
    MaximumColumnWidth: Expr<Length>;
    RangeFillColor: Expr<Color>;
    RangeGradientStyle: GradientType;
    RangeGradientEndColor: Expr<Color>;
    RangeLowerBound: Expr<number>;
    RangeUpperBound: Expr<number>;
    RangeVisibility: boolean;
    SparklineType: SparklineType;
    SeriesValue: Expr<string>;
    Group: Group;
    SortExpressions: Array<SortExpression>;
};
declare type Sparkline = ItemType<'sparkline'> & ReportItemProps & SparklineProps;
declare type BulletProps = {
    LabelFormat: Expr<string>;
    LabelFontFamily: Expr<string>;
    LabelFontSize: Expr<Length>;
    LabelFontStyle: Expr<FontStyle>;
    LabelFontColor: Expr<Color>;
    Orientation: 'Horizontal' | 'Vertical';
    ShowLabels: boolean;
    TargetShape: 'Line' | 'Square' | 'Dot';
    TargetLineColor: Expr<Color>;
    TargetLineWidth: Expr<Length>;
    TickMarks: 'None' | 'Inside' | 'Outside';
    TicksLineColor: Expr<Color>;
    TicksLineWidth: Expr<Length>;
    ValueColor: Expr<Color>;
    BestValue: Expr<number | null>;
    Interval: Expr<number | null>;
    Range1Boundary: Expr<number | null>;
    Range2Boundary: Expr<number | null>;
    TargetValue: Expr<number | null>;
    Value: Expr<number>;
    WorstValue: Expr<number | null>;
};
declare type Bullet = ItemType<'bullet'> & ReportItemProps & BulletProps;
declare type Action = {
    Hyperlink: Expr<string>;
    Drillthrough: {
        ReportName: string;
        Parameters: Array<SubreportParameter>;
    };
    BookmarkLink: Expr<string>;
};
declare type SubreportParameter = {
    ParameterName: string;
    Value: Expr<Variant>;
    Omit: Expr<boolean>;
};
declare type SubreportProps = {
    ReportName: string;
    NoRowsMessage: Expr<string>;
    KeepTogether: boolean;
    MergeTransactions: boolean;
    SubstituteThemeOnSubreport: boolean;
    InheritStyleSheet: boolean;
    Parameters: Array<SubreportParameter>;
    Style: Style<BorderPropNames | TextPropNames>;
    OverflowName: string | null;
};
declare type Subreport = ItemType<'subreport'> & ReportItemProps & SubreportProps;
declare type ChartPalette = 'Default' | 'EarthTones' | 'Excel' | 'GrayScale' | 'Light' | 'Pastel' | 'SemiTransparent' | 'Custom';
declare type ChartType = 'Column' | 'Bar' | 'Line' | 'Pie' | 'Scatter' | 'Bubble' | 'Area' | 'Doughnut' | 'Stock';
declare type ChartSubType = 'Plain' | 'Stacked' | 'PercentStacked' | 'Smooth' | 'Exploded' | 'Line' | 'SmoothLine' | 'HighLowClose' | 'OpenHighLowClose' | 'Candlestick';
declare type ProjectionMode = 'Perspective' | 'Orthographic';
declare type ShadingMode = 'None' | 'Simple' | 'Real';
declare type ChartTitlePosition = 'Center' | 'Near' | 'Far';
declare type TickMarksType = 'None' | 'Inside' | 'Outside' | 'Cross';
declare type PlotType = 'Auto' | 'Line';
declare type DataLabelPosition = 'Auto' | 'Top' | 'TopLeft' | 'TopRight' | 'Left' | 'Center' | 'Right' | 'BottomRight' | 'Bottom' | 'BottomLeft';
declare type MarkerType = 'None' | 'Square' | 'Circle' | 'Diamond' | 'Triangle' | 'Cross' | 'Auto';
declare type LegendPosition = 'TopLeft' | 'TopCenter' | 'TopRight' | 'LeftTop' | 'LeftCenter' | 'LeftBottom' | 'RightTop' | 'RightCenter' | 'RightBottom' | 'BottomRight' | 'BottomCenter' | 'BottomLeft';
declare type LegendLayout = 'Column' | 'Row' | 'Table';
declare type TextOrientation = 'Auto' | 'Horizontal' | 'Rotated90' | 'Rotated270' | 'Stacked';
declare type DataLabel = {
    Style: Style<'Color' | 'TextDecoration' | FontPropNames>;
    Value: Variant;
    Visible: boolean;
    Position: DataLabelPosition;
    Rotation: number;
};
declare type Marker = {
    MarkerType: MarkerType;
    Size: Length;
    Style: CommonStyle;
};
declare type PropsNullable<T> = {
    [K in keyof T]: T[K] | null;
};
declare type DataPointStyle = PropsNullable<Style<'BackgroundColor' | 'Color'>> & Style<'TextDecoration' | FontPropNames> & {
    Border: PropsNullable<BorderSideStyle>;
};
declare type DataPoint = {
    DataValues: Array<Expr<Variant>>;
    DataLabel: DataLabel;
    Action: Action;
    Style: DataPointStyle;
    Marker: Marker;
    DataElementName: string;
    DataElementOutput: DataElementOutput;
};
declare type ChartGrouping = {
    StaticGrouping?: StaticGrouping;
    DynamicGrouping?: DynamicGrouping;
};
declare type ChartSeries = {
    DataPoints: Array<DataPoint>;
    PlotType: PlotType;
    ValueAxisName: string;
    ChartType: 'Auto' | ChartType;
    Subtype: ChartSubType;
};
declare type ChartLegend = {
    Visible: boolean;
    UseSmartSettings: boolean;
    Style: Style<'BackgroundColor' | 'Color' | 'TextDecoration' | 'Border' | FontPropNames>;
    Position: LegendPosition;
    Layout: LegendLayout;
    InsidePlotArea: boolean;
};
declare type ChartTitle = {
    Caption: Expr<string>;
    Style: Style<'BackgroundColor' | 'Color' | 'TextDecoration' | 'Format' | 'Border' | FontPropNames>;
    Position: ChartTitlePosition;
    TextOrientation: TextOrientation;
    Vertical: boolean;
};
declare type ReferenceLine = {
    Value: Expr<Variant>;
    Style: Style<'Border'>;
    LegendLabel: string;
};
declare type GridLines = {
    ShowGridLines: boolean;
    Style: Style<'Border'>;
};
declare type ChartAxis = {
    AxisName: string;
    Location: string;
    AngledLabels: boolean;
    Visible: boolean;
    Style: Style<'Border' | 'Color' | 'TextDecoration' | 'Format' | FontPropNames>;
    Title: ChartTitle;
    Margin: boolean;
    MajorTickMarks: TickMarksType;
    MinorTickMarks: TickMarksType;
    MajorGridLines: GridLines;
    MinorGridLines: GridLines;
    MajorInterval: Expr<number>;
    MinorInterval: Expr<number>;
    Reverse: boolean;
    CrossAt: Expr<number> | null;
    Interlaced: boolean;
    Scalar: boolean;
    Min: Expr<Variant>;
    Max: Expr<Variant>;
    LogScale: boolean;
    ReferenceLine: ReferenceLine;
    EndCap: Expr<string>;
};
declare type ThreeDProperties = {
    Enabled: boolean;
    ProjectionMode: ProjectionMode;
    Rotation: number;
    Inclination: number;
    Perspective: number;
    Shading: ShadingMode;
    WallThickness: number;
    Clustered: boolean;
};
declare type PlotArea = {
    Style: Style<'BackgroundColor' | 'Border'>;
};
declare type Chart = ItemType<'chart'> & ReportItemProps & DataRegionProps & {
    ChartType: ChartType;
    Subtype: ChartSubType;
    DataElementOutput: DataElementOutput;
    SeriesGroupings: Array<ChartGrouping>;
    CategoryGroupings: Array<ChartGrouping>;
    ChartData: Array<ChartSeries>;
    Legend: ChartLegend;
    CategoryAxis: ChartAxis;
    ValueAxes: Array<ChartAxis>;
    Title: ChartTitle;
    PointWidth: number;
    Palette: ChartPalette;
    ThreeDProperties: ThreeDProperties;
    PlotArea: PlotArea;
    CustomPaletteColors: Array<Expr<Color>>;
    Style: Style<BorderPropNames | 'BackgroundColor' | 'BackgroundImage' | 'BackgroundGradientEndColor' | 'BackgroundGradientType' | 'Calendar' | 'Direction' | 'Language' | 'NumeralLanguage' | 'NumeralVariant' | 'WritingMode'>;
};
declare type ThreeStateBool = 'Auto' | 'True' | 'False';
declare type DataSource = {
    Name: string;
    Transaction: boolean;
    DataSourceReference: string;
    ConnectionProperties: ConnectionProperties;
};
declare type ConnectionProperties = {
    DataProvider: string;
    ConnectString: Expr<string>;
    IntegratedSecurity: boolean;
    Prompt: string;
};
declare type DataSet = {
    Name: string;
    Fields: Array<Field>;
    Query: Query;
    Filters: Array<Filter>;
    CaseSensitivity: ThreeStateBool;
    Collation: string;
    KanatypeSensitivity: ThreeStateBool;
    AccentSensitivity: ThreeStateBool;
    WidthSensitivity: ThreeStateBool;
};
declare type Field = {
    Name: string;
    DataField: string;
    Value: Expr<Variant>;
};
declare type Query = {
    DataSourceName: string;
    CommandType: 'Text' | 'StoredProcedure' | 'TableDirect';
    CommandText: string;
    QueryParameters: Array<QueryParameter>;
    Timeout: number;
};
declare type QueryParameter = {
    Name: string;
    Value: Expr<Variant>;
};
declare type LocalizationResource = {
    Language: string;
    Data: Array<{
        Name: string;
        Value: Expr<Variant>;
    }>;
};
declare type DvTextStyleProps = FontPropNames | 'Color' | 'TextDecoration';
declare type DVChart = ItemType<'dvchart'> & ReportItemProps & Pick<DataRegionProps, Exclude<keyof DataRegionProps, 'KeepTogether'>> & {
    Style: Style<BorderPropNames | TextPropNames | 'BackgroundColor' | 'BackgroundImage' | 'BackgroundGradientType' | 'BackgroundGradientEndColor'>;
    Bar: {
        BottomWidth: number | null;
        NeckHeight: number | null;
        Overlap: number | null;
        TopWidth: number | null;
        Width: number | null;
    };
    Header: DVHeaderFooter;
    Footer: DVHeaderFooter;
    Palette: string;
    CustomPalette: string[];
    Legend: DVGlobalLegendOption;
    PlotArea: DVPlotArea;
    Plots: DVPlot[];
};
declare type DVHeaderFooter = {
    Style: Style<'BackgroundColor' | 'Border' | PaddingPropNames>;
    TextStyle: Style<DvTextStyleProps>;
    Title: Expr<string>;
    Height: number;
    HAlign: 'Center' | 'Left' | 'Right';
    VAlign: 'Middle' | 'Bottom' | 'Top';
};
declare type DVPlotArea = {
    Axes: DVAxis[];
    Legends: DVLegendOption[];
    Style: Style<'BackgroundColor' | 'Border' | PaddingPropNames>;
};
declare type DVLegendCommonOption = {
    Hidden: boolean;
    Orientation: 'Horizontal' | 'Vertical';
    Position: 'Left' | 'Right' | 'Top' | 'Bottom';
    Style: Style<'BackgroundColor' | 'Border' | PaddingPropNames>;
    TextStyle: Style<DvTextStyleProps>;
    TitleStyle: Style<DvTextStyleProps>;
};
declare type DVLegendOption = DVLegendCommonOption & {
    Title: Expr<string>;
    LegendType: 'Color' | 'Shape' | 'Size';
};
declare type DVGlobalLegendOption = DVLegendCommonOption & {
    Wrapping: boolean;
};
declare type DVAxis = {
    AxisLine: boolean;
    Format: Expr<string>;
    LabelAngle: number;
    LabelStyle: Style<DvTextStyleProps | PaddingPropNames>;
    Labels: boolean;
    LineStyle: Style<'Border'>;
    LogBase: number;
    MajorGrid: boolean;
    MajorGridStyle: Style<'Border'>;
    MajorTickSize: Expr<Length>;
    MajorTickStyle: Style<'Border'>;
    MajorTicks: 'Inside' | 'Outside' | 'Cross' | 'None';
    MajorUnit: Expr<number> | null;
    Max: Expr<number> | null;
    Min: Expr<number> | null;
    MinorGrid: boolean;
    MinorGridStyle: Style<'Border'>;
    MinorTickSize: Expr<Length>;
    MinorTickStyle: Style<'Border'>;
    MinorTicks: 'Inside' | 'Outside' | 'Cross' | 'None';
    MinorUnit: Expr<number> | null;
    Origin: Expr<number> | null;
    OverlappingLabels: 'Auto' | 'Show';
    Plots: string[];
    Position: 'Near' | 'Far' | 'None';
    Reversed: boolean;
    Scale: 'Linear' | 'Logarithmic' | 'Ordinal' | 'Percentage';
    Style: Style<never>;
    TextStyle: Style<TextPropNames | 'Color'>;
    Title: Expr<string>;
    TitleStyle: Style<DvTextStyleProps | PaddingPropNames>;
    AxisType: 'X' | 'Y';
};
declare type DVPlot = {
    PlotType: 'Bar' | 'Line' | 'Area' | 'Scatter' | string;
    PlotName: string;
    Encodings: DVPlotEncodings;
    Config: DVPlotConfig;
};
declare type DVPlotConfig = {
    Action: Action;
    AxisMode: 'Radial' | 'Cartesian' | '';
    BarLines: boolean;
    ClippingMode: 'Clip' | 'Fit' | 'None';
    ShowNulls: 'Connected' | 'Gaps' | 'Zeros';
    Radial: boolean;
    StartAngle: number;
    Sweep: number;
    Offset: number;
    Opacity: number;
    InnerRadius: number;
    LineStyle: BorderSideStyle;
    Style: Style<'BackgroundColor'>;
    SymbolStyle: Style<'Border' | 'BackgroundColor'>;
    SymbolShape: 'Auto' | 'Dot' | 'Box' | 'Diamond' | 'Triangle' | 'X' | 'Dash' | 'Plus';
    SymbolOpacity: number;
    SwapAxes: boolean;
    Symbols: boolean;
    LineAspect: 'Default' | 'Spline' | 'StepCenter' | 'StepLeft' | 'StepRight';
    Text: DVTextConfig;
    Tooltip: {
        Template: Expr<string>;
    };
};
declare type DVTextConfig = {
    ConnectingLine: Style<'Border'>;
    LinePosition: 'Auto' | 'Center';
    Offset: number;
    OverlappingLabels: 'Auto' | 'Show';
    TextPosition: 'Auto' | 'Center' | 'Inside' | 'Outside';
    Template: string;
    Style: Style<'BackgroundColor' | 'Border' | DvTextStyleProps>;
};
declare type DVPlotEncodings = {
    Values: (DVAggregateEncodingSimple | DVAggregateEncodingComplex)[];
    Category: DVCategoryEncoding;
    Details: DVDetailEncoding[];
    Color: DVAggregateEncodingSimple;
    Shape: DVAggregateEncodingSimple;
    Size: DVAggregateEncodingSimple;
    Text: DVAggregateEncodingSimple[];
    Tooltip: DVAggregateEncodingSimple[];
};
declare type DVCategoryEncoding = {
    Field: {
        Value: Expr<Variant>[];
        FieldType: 'Simple';
    };
    Sort: 'None' | 'Ascending' | 'Descending';
    SortingField: Expr<Variant>;
    SortingAggregate: string;
};
declare type DVAggregateEncodingSimple = {
    Field: {
        Value: Expr<Variant>[];
        FieldType: 'Simple';
    };
    Aggregate: string;
};
declare type DVAggregateEncodingComplex = {
    Field: {
        Subfields: {
            Key: string;
            Value: Expr<Variant>;
        }[];
        FieldType: 'Complex';
    };
    Aggregate: string;
};
declare type DVDetailEncoding = {
    Field: {
        Value: Expr<Variant>[];
    };
    Group: 'None' | 'Cluster' | 'Stack';
    ExcludeNulls: boolean;
    Sort: 'None' | 'Ascending' | 'Descending';
    SortingField: Expr<Variant>;
    SortingAggregate: string;
};
declare type BarcodeProps = {
    Value: Expr<Variant>;
    InvalidBarcodeText: Expr<string>;
    Symbology: string;
    CheckSum: boolean;
    BarHeight: Length;
    CaptionGrouping: boolean;
    CaptionLocation: string;
    Code49Options: {
        Grouping: boolean;
        GroupNumber: number;
    };
    DataMatrixOptions: {
        EccMode: string;
        Ecc200SymbolSize: string;
        Ecc200EncodingMode: string;
        Ecc000_140SymbolSize: string;
        StructuredAppend: boolean;
        StructureNumber: number;
        FileIdentifier: number;
        Encoding: string;
    };
    Ean128Fnc1Options: {
        Resolution: number;
        ModuleSize: number;
        BarAdjust: number;
    };
    Gs1CompositeOptions: {
        CompositeType: string;
        Value: Expr<string>;
    };
    MaxiCodeOptions: {
        Mode: string;
    };
    MicroPdf417Options: {
        CompactionMode: string;
        Version: string;
        SegmentIndex: number;
        SegmentCount: number;
        FileID: number;
    };
    MicroQrCodeOptions: {
        Version: string;
        ErrorLevel: string;
        Mask: string;
        Encoding: string;
    };
    NarrowBarWidth: Length;
    NWRation: number;
    Pdf417Options: {
        Columns: number;
        Rows: number;
        ErrorCorrectionLevel: string;
        Pdf417Type: string;
    };
    QrCodeOptions: {
        Connection: boolean;
        ConnectionNumber: number;
        Version: number;
        ErrorLevel: string;
        Mask: string;
        Model: string;
        Encoding: string;
    };
    QuietZone: {
        Left: Length;
        Right: Length;
        Top: Length;
        Bottom: Length;
    };
    Rotation: string;
    RssExpandedStacked: {
        RowCount: number;
    };
    SupplementOptions: {
        Value: string;
        BarHeight: Length;
        CaptionLocation: string;
        Spacing: Length;
    };
    Style: Style<BorderPropNames | FontPropNames | PaddingPropNames | 'BackgroundColor' | 'Color' | 'Format' | 'TextAlign' | 'TextDecoration'>;
    DataElementStyle: DataElementStyle;
};
declare type Barcode = ItemType<'barcode'> & ReportItemProps & BarcodeProps;
declare type FormattedTextProps = {
    EncodeMailMergeFields: boolean;
    Html: Expr<string>;
    MailMergeFields: {
        Name: string;
        Value: Expr<string>;
    }[];
    Style: Style<BorderPropNames | 'BackgroundColor' | 'BackgroundImage'>;
};
declare type FormattedText = ItemType<'formattedtext'> & ReportItemProps & FormattedTextProps;
declare type RDLReport = WithStringExpr<Report>;
declare type RDLPage = WithStringExpr<Page>;
declare type RDLDataSource = WithStringExpr<DataSource>;
declare type RDLDataSet = WithStringExpr<DataSet>;
declare type RDLReportDefinition = PartialTyped<WithStringExpr<Report>>;
declare namespace Def {
    export type Expression = string | number | boolean | null;
    export type SortDirection = 'Ascending' | 'Descending';
    export type FilterOperator = 'Equal' | 'Like' | 'NotEqual' | 'GreaterThan' | 'GreaterThanOrEqual' | 'LessThan' | 'LessThanOrEqual' | 'TopN' | 'BottomN' | 'TopPercent' | 'BottomPercent' | 'In' | 'Between' | 'NotBetween' | 'NotLike' | 'BetweenExclusive';
    export type FilterExpression = {
        Expression: Expression;
        Op: FilterOperator;
        Values: Expression[];
    };
    export type SortExpression = {
        Expression: Expression;
        Direction: SortDirection;
    };
    export type Group = {
        Name: string;
        GroupExpressions?: Expression[];
        Filters?: FilterExpression[];
        Parent?: Expression | null;
    };
    export type Content = {
        Regions: Region[];
        Fields: Expression[];
    };
    export type Region = List | Tablix | Subreport | DataSet | Report | SimpleRegion;
    type RegionBase = {
        Name: string;
        Content: Content;
    };
    export type DataRegion = RegionBase & {
        Filters?: FilterExpression[];
    };
    export type List = DataRegion & {
        type: 'list';
        Group: Group;
        Sort: SortExpression[];
        GroupContent: Content;
        HandleEmptyGroups?: boolean;
    };
    export type TablixMember = {
        Group?: Group | null;
        Sort?: SortExpression[] | null;
        Header?: Content | null;
        Members?: TablixMember[] | null;
    };
    export type TablixRow = {
        Cells: Content[];
    };
    export type Tablix = DataRegion & {
        type: 'tablix';
        ColumnMembers: TablixMember[];
        RowMembers: TablixMember[];
        Body: TablixRow[];
        Sorts: SortExpression[] | null;
    };
    export type Report = DataRegion & {
        type: 'report';
    };
    export type DataSet = DataRegion & {
        type: 'dataset';
        Name: string;
        FieldNames: Expression[];
        Content: Content;
        Parameters: Parameter[];
    };
    export type Parameter = {
        Name: string;
        Value: Expression;
    };
    export type Subreport = DataRegion & {
        type: 'subreport';
        Report: Report;
        Parameters: Parameter[];
    };
    export type SimpleRegion = DataRegion & {
        type: 'simpleregion';
    };
    export const EmptyContent: Content;
    export const IsEmptyContent: (content: Content) => boolean;
    export const Makers: {
        Report: (name: string, content: Content) => Report;
        DataSet: (name: string, filters: FilterExpression[], content: Content, fieldNames?: Expression[], parameters?: Parameter[]) => DataSet;
        Parameter: (name: string, value: Expression) => Parameter;
        SimpleRegion: (name: string, filters: FilterExpression[], content: Content) => SimpleRegion;
        Content: (fields: Expression[], regions?: Region[]) => Content;
        ContentEmpty: Content;
        List: (name: string, content: Content, filters: FilterExpression[], group: Group, sort: SortExpression[], groupContent: Content, hasEmptyGroups?: boolean | undefined) => List;
        Sort: (expression: Expression, direction: SortDirection) => SortExpression;
        Filter: (expression: Expression, op: FilterOperator, values: Expression[]) => FilterExpression;
        Group: (name: string, groupExpressions?: Expression[] | undefined, filters?: FilterExpression[] | undefined, parent?: Expression | null) => Group;
        Subreport: (name: string, report: Report, parameters: Parameter[], content: Content) => Subreport;
        Tablix: (name: string, filters: FilterExpression[] | null, columnMembers: TablixMember[] | null, rowMembers: TablixMember[] | null, content: Content | null, body: TablixRow[] | null, sorts?: SortExpression[] | null) => Tablix;
        TablixMember: (group: Group | null, sort: SortExpression[] | null, header: Content | null, members: TablixMember[] | null) => TablixMember;
        TablixRow: (cells: Content[] | null) => TablixRow;
    };
    export {};
}
//# sourceMappingURL=def.d.ts.map
declare type ReadonlyList<T> = Iterable<T> & {
    getItem(index: number): T;
    length: number;
}; //# sourceMappingURL=memoizeList.d.ts.map
declare namespace DataTree {
    type Snapshot<T> = {
        Definition: Def.Report;
        Data: Scope<T>;
    };
    type DataRegionBase<T> = {
        Scope: Scope<T>;
        Name: string | null;
    };
    type DataRegion<T> = Tablix<T> | List<T>;
    type Scope<T> = {
        Id: number;
        '@': T[];
        Regions: DataRegion<T>[];
    };
    type List<T> = DataRegionBase<T> & {
        Groups: Collection<Scope<T>>;
    };
    type Tablix<T> = DataRegionBase<T> & {
        ColumnMembers: TablixMember<T>[];
        RowMembers: TablixMember<T>[];
        Body: Collection<TablixRow<T>>;
    };
    type TablixMember<T> = {
        IsCollection: boolean;
        Id: number | undefined;
        Header: Scope<T>;
        Members: Collection<TablixMember<T>>;
    };
    type TablixRow<T> = {
        Cells: Scope<T>[];
    };
    type Report<T> = Scope<T>;
    const IsTablix: (dataRegion: any) => dataRegion is Tablix<any>;
    const IsList: (dataRegion: any) => dataRegion is List<any>;
    const IsEmpty: <T>(scope: Scope<T> | null) => boolean;
    const Makers: {
        Scope: <T>(values: T[], regions: DataRegion<T>[] | (() => DataRegion<T>[]), id?: number) => Scope<T>;
        List: <T_1>(scope: Scope<T_1>, groups: Scope<T_1>[] | (() => Iterable<Scope<T_1>>), name?: string | null) => List<T_1>;
        TablixMember: <T_2>(header: Scope<T_2> | null, isCollection: boolean, id: number, members: TablixMember<T_2>[] | (() => Iterable<TablixMember<T_2>>)) => TablixMember<T_2>;
        TablixRow: <T_3>(cells: Scope<T_3>[]) => TablixRow<T_3>;
        Tablix: <T_4>(corner: Scope<T_4>, columnMembers: TablixMember<T_4>[], rowMembers: TablixMember<T_4>[], body: TablixRow<T_4>[] | (() => Iterable<TablixRow<T_4>>), name?: string | null) => Tablix<T_4>;
    };
}
declare type Collection<T> = Array<T> | ReadonlyList<T>; //# sourceMappingURL=dataTree.d.ts.map
declare type SafeValue = number | string | boolean | null; //# sourceMappingURL=dataTreeGenerator.d.ts.map
declare type NodePatch = {
    id: string | null;
    style?: Object | null;
    children?: Array<VNode> | null;
    className?: string | null;
};
declare type SubreportStore = {
    [name: string]: RDLReport;
};
declare type ResolvedStyle = {
    [propName: string]: string;
};
declare type StaticStyle = {
    className: string;
    style: ResolvedStyle;
};
declare type DocumentMapNode = {
    anchor: string;
    name: string | null;
    level: number;
    kids: DocumentMapNode[];
    isLeaf: boolean;
    page: number | null;
};
declare type ToggleAction = {
    Type: 'toggle';
    ScopeId: number;
    ItemPath: Array<string>;
};
declare type ExprScopeSortState = {
    Expression: string;
    Direction: SortDirection;
};
declare type ScopeSortState = {
    [ExpressionScope: string]: ExprScopeSortState;
};
declare type SortState = {
    [ScopeId: number]: ScopeSortState;
};
declare type InteractiveState = {
    Toggles: ToggleAction[];
    SortState: SortState;
};
/**
 *  Layout function type. Given some space performs element layout and returns layout result of type TR.
 *
 * @template TR
 * @param size
 */
declare type LFunc<TR> = (size: number) => Result<TR>;
declare type Layout<T> = LFunc<LFunc<T>>;
/**
 * Defines the layout result type (for covariance).
 *
 * @typeparam TR
 */
declare type Result<TR> = {
    /** Gets the slice size. */
    Size: number;
    /** Gets the slice content. */
    Body: TR | null;
    /** Gets the slice tail. */
    Tail: LFunc<TR> | null;
    /** Gets true if layout failed. */
    IsFailed(): boolean;
    /**
     * Gets true is layout succeeded and there's a continuation.
     * Also returns true in case PageBreakBefore but not PageBreakAfter.
     */
    IsSplit(): boolean;
    /**
     *  Gets true is layout succeeded and there's no reminder (or reminder is zero).
     *  Explicitly check IsPageBreak result to detect latter case.
     */
    IsCompleted(): boolean;
    /**
     * Gets true the result is page break i.e. body is zero and there's a reminder.
     */
    IsPageBreak(): boolean;
    /**
    *  Gets true the slice succeeded (split) while the tail is zero layout.
    */
    IsPageBreakAfter(): boolean;
    /**
    *  Gets true if body is not empty
    */
    IsEmpty(): boolean;
};
declare type PageInfo = {
    PageWidth: string;
    PageHeight: string;
    LeftMargin: string;
    RightMargin: string;
    TopMargin: string;
    BottomMargin: string;
};
/**
 * Provide tools for accessing external resources by URIs.
 */
declare type ResourceLocator = {
    /**
     * Returns resource content.
     */
    getResource: <T>(uri: string) => Promise<T | null>;
    /**
     * Returns absolute resource URI based on relative ID and base path.
     */
    getResourceUri: (resourceID: string) => string;
    /**
     * Creates new ResourceLocator instance based on current one base path.
     * @param reportName Relative path for new report.
     */
    fork(reportName: string): ResourceLocator;
};
/** @module Core/Parameters */ /** */
/** Defines parameter data type. */
declare type ParameterDataType = "Boolean" | "String" | "Integer" | "Float" | "Date" | "DateTime";
/** Special value for multivalue parameter to indicate that all values are set. */
declare const selectAll: SelectAllType;
/** Special value to indicate that value is not set. */
declare const noValue: undefined;
/** Defines special value to indicate that value is not set. */
declare type NoValueType = typeof noValue;
/** Defines special value for multivalue parameter to indicate that all values are set. */
declare type SelectAllType = {
    /** @hidden */
    selectAll: '$selectAll';
};
/** Type of parameter value */
declare type ParameterVariant = string | number | boolean | Date | null | NoValueType | SelectAllType;
/**
 * Defines parameter value
 */
declare type ParameterValue = {
    /** Label to display */
    label: string;
    /** Value */
    value: ParameterVariant;
    /** Additional fields for extended parameter view */
    fields?: any[];
};
/** Defines report parameter descriptor */
declare type ParameterDescriptor = {
    /** Parameter name */
    name: string;
    /** Parameter data type */
    dataType: ParameterDataType;
    /** For multivalue parameter special value to indicate that all available values are selected */
    selectAllValue?: any;
    /** Allow blank */
    allowBlank: boolean;
    /** Allow null */
    nullable: boolean;
    /** Parameter is multivalue */
    multiValue: boolean;
    /** Parameters on which parameter depends */
    dependsOn: string[];
};
/** @hidden */
declare enum ParameterStatus {
    ok = 0,
    expectValue = 1,
    hasOutstandingDependencies = 2,
    validationFailed = 3,
    dynamicValuesUnavailable = 4,
    communicating = 5,
    isValidation = 6
}
declare type GetValuesResult = {
    [key: string]: {
        validValues: ParameterValue[];
        values: any[];
    };
};
declare type SearchResult = {
    id: string;
};
declare type DOMRenderingOptions = {
    /**
     * Specify elements ids to add 'searchHighlight' class
     */
    searchResults?: SearchResult[];
    /**
     * Provide Document instance for creatineg elements (window.document if undefined)
     */
    targetDocument?: Document;
    /**
     * Hide or show toggle and sort icons
     */
    hideInteractivity?: boolean;
};
/** Document render options */
declare type RenderOptions = {
    /** Renders document without splitting the big content to pages. */
    galleyMode: boolean;
    /** Holds sorts/toggles state of the document. */
    interactivityActions: Array<{
        Type: 'toggle';
        Data: string;
    } | {
        Type: 'sort';
        Data: string;
    }>;
};
/** @hidden */
declare class VDomRenderer {
    private readonly documentMapFn;
    private readonly styles;
    private readonly pageInfo;
    private readonly i18n?;
    static create(pageDoc: PageDocument, renderOptions?: RenderOptions, i18n?: i18next.i18n): Promise<VDomRenderer>;
    static renderToDOM(content: VNode, patches?: NodePatch[][], options?: DOMRenderingOptions): HTMLElement;
    static getCssString(style: ResolvedStyle): string;
    private readonly language;
    private readonly pageGenerator;
    private readonly pages;
    private readonly patches;
    private readonly tocLabels;
    private constructor();
    render(): IterableIterator<{
        pageCount: number;
        isComplete: boolean;
    }>;
    getPage(pIndex: number): VNode | null;
    getDelayedContent(pageIndex: number): NodePatch[][] | null;
    getDocumentMap(): {
        kids: DocumentMapNode[];
    };
    resolveBookmark(label: string): number | null;
    getContent(): {
        pageInfo: PageInfo | null;
        pages: VNode[];
        patches: NodePatch[][][];
        styles: StaticStyle[];
    };
    findText(options: SearchOptions): IterableIterator<{
        text: string;
        itemId: string;
        pageIndex: number;
        itemIndex: number;
        position: number;
        length: number;
    }>;
    print(onProgress?: (pageCount: number) => void, checkCancel?: () => boolean): Promise<void>;
    getFontFaces(): string;
    private _e;
}
/** @hidden */
declare type SearchOptions = {
    PageIndex: number;
    ItemIndex: number;
    Text: string;
    MatchCase: boolean;
    WholeWord: boolean;
    SearchBackward: boolean;
};
/** @hidden */
declare type DataDocumentMapFn = () => {
    kids: DocumentMapNode[];
};
/** @hidden */
interface IReportDataProvider {
    fetchReportData(query: Def.Report, parameters: {
        [name: string]: ParameterVariant | ParameterVariant[];
    }): Promise<IReportDataSnapshot>;
}
/** @hidden */
interface IReportDataSnapshot {
    dataTree: DataTree.Scope<SafeValue>;
    applySort(sortState: any): Promise<DataTree.Scope<SafeValue>>;
}
/**
 * Report environment used for expressions calculation.
 */
declare type Environment = {
    /** Report name */
    readonly ReportName?: string;
    /** Report directory name */
    readonly ReportFolder?: string;
};
/** Represents rendered report. */
declare class PageDocument {
    private readonly report;
    private readonly i18n;
    /*@hidden */
    readonly styles: StaticStyle[];
    /** @hidden */
    static create(reportDefinition: RDLReport, ctx: Environment, resourceLocator: ResourceLocator, parameters: {
        [name: string]: ParameterVariant | ParameterVariant[];
    }, getDataProvider: (subreports: SubreportStore) => Promise<IReportDataProvider>, i18n: i18next.i18n): Promise<PageDocument>;
    /** @hidden */
    readonly ctx: Environment;
    /** @hidden */
    readonly pageInfo: RDLPage;
    /** @hidden */
    private sortState;
    private dataLayoutFn;
    private resultTree;
    private readonly data;
    private constructor();
    /** @hidden */
    getLayout(interactivityState: InteractiveState): Promise<{
        layout: Layout<VirtualDOM.VNode>;
        documentMap: DataDocumentMapFn;
    }>;
    /** @hidden */
    runRenderer(renderOptions?: RenderOptions): Promise<VDomRenderer>;
    /** Displays the browser's printing dialog.
     * @param renderOptions  Specifies the rendering options.
     * @param onProgress  Callback for printing progress notifications.
     * @param checkCancel  Allows to cancel report printing.
     */
    print(renderOptions?: RenderOptions, onProgress?: (pageCount: number) => void, checkCancel?: () => boolean): Promise<void>;
}
/** Parameters validation result */
declare type ValidationResults = {
    /** Dictionary with validation results per parameter */
    [parameter: string]: ValidationResult;
};
/** Parameter validation result */
declare type ValidationResult = {
    /** Indicates whether validation success or not. */
    isValid: boolean;
    /** New validated parameter value. */
    value?: any;
    /** The error text in case of validation fails. */
    message?: string;
};
/** @hidden */
declare type RequiredParametersDesc = Record<string, {
    fields: string[];
}>;
/**
 * Parameter descriptor.
 */
declare type ParameterDescriptorEx = ParameterDescriptor & ParameterDescriptorConfig;
/**
 * Parameter visual presentation settings.
 */
declare type ParameterDescriptorConfig = {
    /** Indicates that parameter is hidden. Hidden parameters are not visible in parameter panel. */
    hidden: boolean;
    /** Parameter value prompt. */
    prompt: string;
    /** Date only. For DateTime parameters. */
    dateOnly: boolean;
    /** Multiline. */
    multiline: boolean;
};
/** Defines report parameter */
declare type Parameter = {
    /** Parameter descriptor */
    descriptor: ParameterDescriptorEx;
    /** Valid values */
    validValues: ParameterValue[];
    /** _true_ if valid values list was loaded */
    isValidValuesLoaded: boolean;
    /** Parameter values */
    values: ParameterVariant[];
    /** Shows error message for invalid parameter values */
    errorMessage: string;
};
/** Defines report parameters */
declare type ReportParameters = {
    readonly [name: string]: Parameter;
};
/** PageReport class */
declare class PageReport {
    private readonly i18n;
    /**
     * Create new instance of {@link PageReport} class.
     * @param options pageReport options
     * 	- language: report language. Default language is 'en'.
     */
    constructor(options?: Partial<{
        i18n: i18next.i18n;
        language: string;
    }>);
    /*Gets the report name. */
    readonly name: string;
    /*Gets the report parameters collection. */
    readonly parameters: ReportParameters;
    /*Gets the report resource locator instance. */
    readonly resourceLocator: ResourceLocator;
    /*@deprecated Use setLicenseKey method instead. */
    static LicenseKey: string;
    private _instance;
    private _parameters;
    private _context;
    /** Loads the report template.
     * @param report  URI or the report template or template object.
     * @param options  Execution time settings.
     */
    load(report: string | RDLReportDefinition, options?: {
        environment?: Environment;
        resourceLocator?: Partial<ResourceLocator>;
    }): Promise<void>;
    /** Validates the parameter values.
     * @returns Validation result.
     */
    validateParameters(): ValidationResults;
    /** @hidden */
    execData(requiredParams: RequiredParametersDesc): Promise<{
        [name: string]: {
            validValues: any[];
            values: any;
        };
    }>;
    /** @hidden */
    resolveParametersValues(requiredParams?: string[]): Promise<void>;
    /** Starts rendering the report. */
    run(): Promise<PageDocument>;
}
//# sourceMappingURL=record.d.ts.map
declare type VariantType = 'Null' | 'Bool' | 'Int32' | 'Int64' | 'UInt64' | 'Float' | 'Double' | 'Decimal' | 'TimeSpan' | 'Date' | 'String' | 'Enum' | 'Object';
declare type DataValue = boolean | number | string | null | DataArray | DataObject | undefined | Moment;
interface DataObject {
    [key: string]: DataValue;
}
interface DataArray extends Array<DataValue> {
}
declare type DataFieldsRecords = {
    descriptors: Array<{
        Name: string;
        Type: VariantType | null;
    }>;
    records: IterableIterator<DataValue[]>;
};
declare type DataProvider = {
    init: (connectionString: string, i18n: i18next.WithT, getResourceUri?: (path: string) => string) => {
        openReader: (dataset: RDLDataSet) => Promise<DataFieldsRecords>;
        openReaderSync: (dataset: RDLDataSet) => DataFieldsRecords;
    };
};
type rdlxparams_d_ParameterStatus = ParameterStatus;
declare const rdlxparams_d_ParameterStatus: typeof ParameterStatus;
type rdlxparams_d_ParameterVariant = ParameterVariant;
type rdlxparams_d_GetValuesResult = GetValuesResult;
declare namespace rdlxparams_d {
    export { rdlxparams_d_ParameterStatus as ParameterStatus, rdlxparams_d_ParameterVariant as ParameterVariant, rdlxparams_d_GetValuesResult as GetValuesResult, };
}
/**
 * Set ARJS license key
 * @param key license key value
 */
declare function setLicenseKey(key: string): void;
/** @hidden */
declare function getLicenseKey(): string;
/** @hidden */
declare const arjsStyles: string;
declare type Report$1 = PartialTyped<RDLReport>;
declare type DataSet$1 = PartialTyped<RDLDataSet>;
declare type DataSource$1 = PartialTyped<RDLDataSource>;
declare namespace rdlxModel_d {
    export { Report$1 as Report, DataSet$1 as DataSet, DataSource$1 as DataSource, };
}
/** @module Core */ /** */
/**
 * Font file descriptor
 */
interface FontDescriptor {
    /** Font family name, e.g. "Segoe UI" */
    name: string;
    /** Font file URI, supported file formats are *.ttf, *.otf and *.woff */
    source: string | string[];
    /** Fallback fonts that will be searched on the local machine */
    locals?: string[];
    /** Font weight, e.g. "bold" */
    weight?: string;
    /** Font style, e.g. "italic" */
    style?: string;
    /** The font postscript name. */
    postscriptName?: string;
    /** True - to use the font as default font in PDF export. */
    useAsDefault?: boolean;
}
/**
 * @deprecated Use FontStore.registerFonts instead
 * Registers and loads user-specified fonts
 * @param fonts Set of font descriptors to be registered
 * @returns Promise that will be resolved when all fonts are loaded and ready for render
 */
declare function registerFont(...fonts: FontDescriptor[]): Promise<void>;
/**
 * Provides tools for registering fonts in CSS and pdf export.
 */
declare const FontStore: {
    /**
     * @param ...fonts List of FontDescriptor
     * Register specified fonts in CSS and pdf export. Helps display export correctly on machines where fonts can be missed.
     *
     * ```javascript
     * type FontDescriptor = {
     *     name: string,
     *     source: string,
     *     weight?: 'normal' | 'bold' | '100' | '200' | '300' | '400' | '500' | '600' | '700' | '800' | '900',
     *     style?: 'normal' | 'italic' | 'oblique'
     * }
     *
     *
     * var arial = {
     *     name: 'Arial',
     *     source: 'fonts/arial.ttf',
     *     style: 'italic',
     *     weight: '700',
     * };
     *
     *
     * var gothic = {
     *     name: 'MS PGothic',
     *     source: 'fonts/MS-PGothic.ttf'
     * };
     *
     *
     * FontStore.registerFonts(arial);
     * //OR
     * FontStore.registerFonts(arial, gothic);
     * //OR
     * var fonts = [arial, gothic]; FontStore.registerFonts(...fonts);
     * ```
     *
     * @param configUri Path to fontsConfig.json file
     * Register fonts specified in onfig file.
     * ```javascript
     * FontStore.registerFonts('./fontsConfig.json');
     * ```
     * @returns Promise<void>
     */
    registerFonts: ((...fonts: FontDescriptor[]) => Promise<void>) & ((configUri: string) => Promise<void>);
    /**
     * Get registered font descriptors.
     * @returns List of registered font descriptors.
     */
    getFonts: () => FontDescriptor[];
};
/** @hidden */
declare const DataProviders: Record<'CSV' | 'JSON', DataProvider>;
/** @hidden */
declare const Version: string;
export { DataProviders, Environment, FontDescriptor, FontStore, NoValueType, PageDocument, PageReport, Parameter, ParameterDataType, ParameterDescriptor, ParameterDescriptorConfig, ParameterDescriptorEx, ParameterValue, ParameterVariant, RDLReportDefinition, rdlxModel_d as RDLX, RenderOptions, ReportParameters, ResourceLocator, SelectAllType, VDomRenderer, ValidationResult, ValidationResults, Version, arjsStyles, getLicenseKey, noValue, rdlxparams_d as rdlxParams, registerFont, selectAll, setLicenseKey };
